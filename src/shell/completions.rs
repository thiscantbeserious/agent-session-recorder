//! Shell completion and initialization code generation
//!
//! This module handles generating dynamic shell initialization code with
//! embedded completions. Completions are dynamically generated from clap
//! command definitions rather than static files.

use std::fs;
use std::io;

use clap::CommandFactory;

use super::paths::{bash_completion_path, zsh_completion_path};
use crate::cli::Cli;

// ============================================================================
// Legacy completion file cleanup
// ============================================================================

/// Clean up old completion files from legacy installation
///
/// This removes static completion files that were installed by earlier
/// versions of agr. Completions are now embedded in the RC file section.
pub fn cleanup_old_completions() -> io::Result<()> {
    // Remove old zsh completion file
    if let Some(path) = zsh_completion_path() {
        if path.exists() {
            fs::remove_file(&path)?;
        }
    }

    // Remove old bash completion file
    if let Some(path) = bash_completion_path() {
        if path.exists() {
            fs::remove_file(&path)?;
        }
    }

    Ok(())
}

// ============================================================================
// Dynamic shell init code generation (REQ-1)
// ============================================================================

/// Information about a CLI command for completion
#[derive(Debug, Clone)]
pub struct CommandInfo {
    /// Command name
    pub name: String,
    /// Short description from clap's `about`
    pub description: String,
    /// Whether this command accepts a file argument
    pub accepts_file: bool,
}

/// Extract command information from clap definitions
///
/// Uses `CommandFactory` to introspect the CLI and extract all subcommands
/// with their descriptions.
pub fn extract_commands() -> Vec<CommandInfo> {
    let cmd = Cli::command();
    cmd.get_subcommands()
        .filter(|sub| !sub.is_hide_set()) // Skip hidden commands like "completions"
        .map(|sub| CommandInfo {
            name: sub.get_name().to_string(),
            description: sub.get_about().map(|s| s.to_string()).unwrap_or_default(),
            accepts_file: is_file_accepting(sub.get_name()),
        })
        .collect()
}

/// Check if a command accepts a file argument for completion
fn is_file_accepting(cmd: &str) -> bool {
    matches!(
        cmd,
        "play" | "analyze" | "optimize" | "marker" | "list" | "ls" | "cleanup"
    )
}

/// Generate zsh initialization code with embedded completions and ghost text
///
/// The generated code includes:
/// - `_AGR_LOADED=1` marker to detect if integration is loaded
/// - Embedded command list from clap
/// - Two-layer completion: commands first, then files for file-accepting commands
/// - Ghost text autosuggestion for file-accepting commands
pub fn generate_zsh_init() -> String {
    let commands = extract_commands();

    // Build command array entries with descriptions for _describe
    let cmd_entries: Vec<String> = commands
        .iter()
        .map(|c| {
            let desc = c.description.replace('\'', "'\\''"); // Escape single quotes
            format!("'{}:{}'", c.name, desc)
        })
        .collect();
    let cmd_array = cmd_entries.join(" ");

    // Also build a simple space-separated list for quick checks
    let cmd_names: Vec<&str> = commands.iter().map(|c| c.name.as_str()).collect();
    let cmd_list = cmd_names.join(" ");

    // File-accepting commands for dynamic file completion (pipe-separated for regex)
    let file_cmds: Vec<&str> = commands
        .iter()
        .filter(|c| c.accepts_file)
        .map(|c| c.name.as_str())
        .collect();
    let file_cmd_pattern = file_cmds.join("|");

    // File-accepting commands for ghost text (space-separated for simple check)
    let file_cmds_space = file_cmds.join(" ");

    format!(
        r#"# AGR Shell Integration - Zsh
# Generated by: agr completions --shell-init zsh
export _AGR_LOADED=1
_agr_commands=({cmd_array})
_agr_cmd_names="{cmd_list}"
_agr_file_cmds="{file_cmd_pattern}"
_agr_file_cmds_space="{file_cmds_space}"

# Enable menu selection for completions (Tab cycles through options)
zstyle ':completion:*:*:agr:*' menu select
zstyle ':completion:*:*:agr:*' format '%F{{8}}-- %d --%f'

# Helper: complete with cast files
_agr_complete_files() {{
    local cur="$1"
    local -a files
    files=(${{(f)"$(agr completions --files --limit 20 "$cur" 2>/dev/null)"}})
    (( $#files )) && _describe 'recordings' files
}}

# Two-layer completion: commands first, then files for file-accepting commands
_agr_complete() {{
    local cur="${{words[CURRENT]}}"
    local cmd="${{words[2]}}"

    if (( CURRENT == 2 )); then
        _describe 'commands' _agr_commands
    elif [[ " $_agr_file_cmds_space " =~ " $cmd " ]]; then
        _agr_complete_files "$cur"
    elif [[ "$cmd" == "marker" ]] && (( CURRENT == 4 )); then
        _agr_complete_files "$cur"
    fi
}}

compdef _agr_complete agr
"#
    )
}

/// Generate bash initialization code with embedded completions and ghost text
///
/// The generated code includes:
/// - `_AGR_LOADED=1` marker to detect if integration is loaded
/// - Embedded command list from clap
/// - Two-layer completion: commands first, then files for file-accepting commands
/// - Ghost text autosuggestion for file-accepting commands (limited in bash)
pub fn generate_bash_init() -> String {
    let commands = extract_commands();

    // Build simple space-separated command list
    let cmd_names: Vec<&str> = commands.iter().map(|c| c.name.as_str()).collect();
    let cmd_list = cmd_names.join(" ");

    // File-accepting commands
    let file_cmds: Vec<&str> = commands
        .iter()
        .filter(|c| c.accepts_file)
        .map(|c| c.name.as_str())
        .collect();
    let file_cmd_pattern = file_cmds.join(" ");

    format!(
        r#"# AGR Shell Integration - Bash
# Generated by: agr completions --shell-init bash
export _AGR_LOADED=1
_agr_commands="{cmd_list}"
_agr_file_cmds="{file_cmd_pattern}"

# Helper: complete with cast files
_agr_complete_files() {{
    local cur="$1"
    local files
    files=$(agr completions --files --limit 20 "$cur" 2>/dev/null)
    COMPREPLY=($(compgen -W "$files" -- "$cur"))
}}

_agr_complete() {{
    local cur="${{COMP_WORDS[COMP_CWORD]}}"
    local cmd="${{COMP_WORDS[1]}}"

    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($(compgen -W "$_agr_commands" -- "$cur"))
    elif [[ " $_agr_file_cmds " =~ " $cmd " ]]; then
        _agr_complete_files "$cur"
    elif [[ "$cmd" == "marker" ]] && [[ $COMP_CWORD -eq 3 ]]; then
        _agr_complete_files "$cur"
    fi
}}

complete -F _agr_complete agr
"#
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn extract_commands_returns_visible_commands() {
        let commands = extract_commands();
        let names: Vec<&str> = commands.iter().map(|c| c.name.as_str()).collect();

        // Should include common commands
        assert!(names.contains(&"record"), "Should contain 'record'");
        assert!(names.contains(&"play"), "Should contain 'play'");
        assert!(names.contains(&"list"), "Should contain 'list'");
        assert!(names.contains(&"status"), "Should contain 'status'");

        // Should NOT include hidden commands
        assert!(
            !names.contains(&"completions"),
            "Should not contain hidden 'completions'"
        );
    }

    #[test]
    fn extract_commands_marks_file_accepting() {
        let commands = extract_commands();

        let play = commands.iter().find(|c| c.name == "play");
        assert!(play.is_some());
        assert!(play.unwrap().accepts_file);

        let analyze = commands.iter().find(|c| c.name == "analyze");
        assert!(analyze.is_some());
        assert!(analyze.unwrap().accepts_file);

        let status = commands.iter().find(|c| c.name == "status");
        assert!(status.is_some());
        assert!(!status.unwrap().accepts_file);
    }

    #[test]
    fn generate_zsh_init_contains_marker() {
        let init = generate_zsh_init();
        assert!(init.contains("_AGR_LOADED=1"));
    }

    #[test]
    fn generate_zsh_init_contains_commands() {
        let init = generate_zsh_init();
        assert!(init.contains("record"));
        assert!(init.contains("play"));
        assert!(init.contains("status"));
    }

    #[test]
    fn generate_zsh_init_contains_completion_function() {
        let init = generate_zsh_init();
        assert!(init.contains("_agr_complete()"));
        assert!(init.contains("compdef _agr_complete agr"));
    }

    #[test]
    fn generate_bash_init_contains_marker() {
        let init = generate_bash_init();
        assert!(init.contains("_AGR_LOADED=1"));
    }

    #[test]
    fn generate_bash_init_contains_commands() {
        let init = generate_bash_init();
        assert!(init.contains("record"));
        assert!(init.contains("play"));
        assert!(init.contains("status"));
    }

    #[test]
    fn generate_bash_init_contains_completion_function() {
        let init = generate_bash_init();
        assert!(init.contains("_agr_complete()"));
        assert!(init.contains("complete -F _agr_complete agr"));
    }

    #[test]
    fn zsh_init_is_valid_shell_syntax() {
        let init = generate_zsh_init();
        // Basic syntax checks - verify shell variables are properly formed
        assert!(init.contains("${"), "Should have shell variable syntax");
        assert!(
            !init.contains("{cmd_"),
            "Should not have unescaped format placeholders"
        );
        assert!(
            !init.contains("{{"),
            "Should not have double braces (format! escape artifacts)"
        );
    }

    #[test]
    fn bash_init_is_valid_shell_syntax() {
        let init = generate_bash_init();
        // Basic syntax checks - verify shell variables are properly formed
        assert!(init.contains("${"), "Should have shell variable syntax");
        assert!(
            !init.contains("{cmd_"),
            "Should not have unescaped format placeholders"
        );
        assert!(
            !init.contains("{{"),
            "Should not have double braces (format! escape artifacts)"
        );
    }

    #[test]
    fn zsh_init_enables_menu_selection() {
        let init = generate_zsh_init();
        assert!(
            init.contains("menu select"),
            "Should enable menu selection for Tab cycling"
        );
    }

    #[test]
    fn bash_init_uses_complete() {
        let init = generate_bash_init();
        assert!(
            init.contains("complete -F _agr_complete agr"),
            "Should register completion function"
        );
    }
}
