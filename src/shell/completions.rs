//! Shell completion and initialization code generation
//!
//! This module handles generating dynamic shell initialization code with
//! embedded completions. Completions are dynamically generated from clap
//! command definitions rather than static files.

use std::fs;
use std::io;

use clap::CommandFactory;

use super::paths::{bash_completion_path, zsh_completion_path};
use crate::cli::Cli;

// ============================================================================
// Legacy completion file cleanup
// ============================================================================

/// Clean up old completion files from legacy installation
///
/// This removes static completion files that were installed by earlier
/// versions of agr. Completions are now embedded in the RC file section.
pub fn cleanup_old_completions() -> io::Result<()> {
    // Remove old zsh completion file
    if let Some(path) = zsh_completion_path() {
        if path.exists() {
            fs::remove_file(&path)?;
        }
    }

    // Remove old bash completion file
    if let Some(path) = bash_completion_path() {
        if path.exists() {
            fs::remove_file(&path)?;
        }
    }

    Ok(())
}

// ============================================================================
// Dynamic shell init code generation (REQ-1)
// ============================================================================

/// Information about a CLI command for completion
#[derive(Debug, Clone)]
pub struct CommandInfo {
    /// Command name
    pub name: String,
    /// Short description from clap's `about`
    pub description: String,
    /// Whether this command accepts a file argument
    pub accepts_file: bool,
}

/// Extract command information from clap definitions
///
/// Uses `CommandFactory` to introspect the CLI and extract all subcommands
/// with their descriptions.
pub fn extract_commands() -> Vec<CommandInfo> {
    let cmd = Cli::command();
    cmd.get_subcommands()
        .filter(|sub| !sub.is_hide_set()) // Skip hidden commands like "completions"
        .map(|sub| CommandInfo {
            name: sub.get_name().to_string(),
            description: sub.get_about().map(|s| s.to_string()).unwrap_or_default(),
            accepts_file: is_file_accepting(sub.get_name()),
        })
        .collect()
}

/// Check if a command accepts a file argument for completion
fn is_file_accepting(cmd: &str) -> bool {
    matches!(
        cmd,
        "play" | "analyze" | "optimize" | "marker" | "list" | "ls" | "cleanup"
    )
}

/// Generate zsh initialization code with embedded completions and ghost text
///
/// The generated code includes:
/// - `_AGR_LOADED=1` marker to detect if integration is loaded
/// - Embedded command list from clap
/// - Two-layer completion: commands first, then files for file-accepting commands
/// - Ghost text autosuggestion for file-accepting commands
pub fn generate_zsh_init() -> String {
    let commands = extract_commands();

    // Build command array entries with descriptions for _describe
    let cmd_entries: Vec<String> = commands
        .iter()
        .map(|c| {
            let desc = c.description.replace('\'', "'\\''"); // Escape single quotes
            format!("'{}:{}'", c.name, desc)
        })
        .collect();
    let cmd_array = cmd_entries.join(" ");

    // Also build a simple space-separated list for quick checks
    let cmd_names: Vec<&str> = commands.iter().map(|c| c.name.as_str()).collect();
    let cmd_list = cmd_names.join(" ");

    // File-accepting commands for dynamic file completion (pipe-separated for regex)
    let file_cmds: Vec<&str> = commands
        .iter()
        .filter(|c| c.accepts_file)
        .map(|c| c.name.as_str())
        .collect();
    let file_cmd_pattern = file_cmds.join("|");

    // File-accepting commands for ghost text (space-separated for simple check)
    let file_cmds_space = file_cmds.join(" ");

    format!(
        r#"# AGR Shell Integration - Zsh
# Generated by: agr completions --shell-init zsh
export _AGR_LOADED=1
_agr_ghost_style=$'\e[37;100m'
_agr_reset=$'\e[0m'
_agr_commands=({cmd_array})
_agr_cmd_names="{cmd_list}"
_agr_file_cmds="{file_cmd_pattern}"
_agr_file_cmds_space="{file_cmds_space}"

# Two-layer completion: commands first, then files for file-accepting commands
_agr_complete() {{
    local cur="${{words[CURRENT]}}"
    local cmd="${{words[2]}}"

    if (( CURRENT == 2 )); then
        # First argument: complete command names with descriptions
        _describe 'commands' _agr_commands
    elif [[ " $_agr_file_cmds_space " =~ " $cmd " ]]; then
        # File-accepting command: complete with cast files
        local -a files
        files=(${{(f)"$(agr completions --files --limit 20 "$cur" 2>/dev/null)"}})
        if (( $#files )); then
            _describe 'cast files' files
        fi
    elif [[ "$cmd" == "marker" ]] && (( CURRENT == 4 )); then
        # marker add/list <file>: complete with cast files
        local -a files
        files=(${{(f)"$(agr completions --files --limit 20 "$cur" 2>/dev/null)"}})
        if (( $#files )); then
            _describe 'cast files' files
        fi
    fi
}}

compdef _agr_complete agr

# =============================================================================
# Ghost text autosuggestion (inline file suggestions)
# =============================================================================
_agr_ghost_text=""
_agr_original_space_widget=""

# Show ghost text suggestion when at file-accepting position
_agr_show_ghost() {{
    local buf="$BUFFER"
    _agr_ghost_text=""
    POSTDISPLAY=""

    # Check if we're at a file-accepting position (command followed by space)
    if [[ "$buf" =~ ^agr\ ({file_cmd_pattern})\ $ ]]; then
        local suggestion
        suggestion=$(agr completions --files --limit 1 2>/dev/null)
        if [[ -n "$suggestion" ]]; then
            _agr_ghost_text="$suggestion"
            # Gray text (90) + dim background (100)
            POSTDISPLAY="${{_agr_ghost_style}}$suggestion${{_agr_reset}}"
        fi
    elif [[ "$buf" =~ ^agr\ marker\ (add|list)\ $ ]]; then
        local suggestion
        suggestion=$(agr completions --files --limit 1 2>/dev/null)
        if [[ -n "$suggestion" ]]; then
            _agr_ghost_text="$suggestion"
            POSTDISPLAY="${{_agr_ghost_style}}$suggestion${{_agr_reset}}"
        fi
    fi
}}

# Accept the ghost text suggestion
_agr_accept_ghost() {{
    if [[ -n "$_agr_ghost_text" ]]; then
        BUFFER="$BUFFER$_agr_ghost_text"
        CURSOR=${{#BUFFER}}
        _agr_ghost_text=""
        POSTDISPLAY=""
        zle redisplay
        return 0
    fi
    # Fall through to default behavior (completion)
    return 1
}}

# Clear ghost text
_agr_clear_ghost() {{
    if [[ -n "$_agr_ghost_text" ]]; then
        _agr_ghost_text=""
        POSTDISPLAY=""
    fi
}}

# Widget: self-insert that triggers ghost text display
_agr_self_insert_ghost() {{
    zle self-insert
    _agr_show_ghost
}}

# Widget: Tab key handler - accept ghost or fall back to completion
_agr_tab_handler() {{
    if [[ -n "$_agr_ghost_text" ]]; then
        _agr_accept_ghost
    else
        # Fall back to normal completion
        zle expand-or-complete
    fi
}}

# Widget: Right arrow accepts ghost text or moves cursor
_agr_right_arrow_handler() {{
    if [[ -n "$_agr_ghost_text" ]] && [[ $CURSOR -eq ${{#BUFFER}} ]]; then
        _agr_accept_ghost
    else
        zle forward-char
    fi
}}

# Widget: Any other key clears ghost text
_agr_clear_and_self_insert() {{
    _agr_clear_ghost
    zle self-insert
}}

# Register widgets
zle -N _agr_self_insert_ghost
zle -N _agr_tab_handler
zle -N _agr_right_arrow_handler
zle -N _agr_accept_ghost

# Bind space to trigger ghost display
bindkey ' ' _agr_self_insert_ghost

# Tab accepts ghost or falls back to completion
bindkey '^I' _agr_tab_handler

# Right arrow accepts ghost at end of line
bindkey '^[[C' _agr_right_arrow_handler

# Clear ghost on line editor start
autoload -Uz add-zle-hook-widget
_agr_line_init_hook() {{
    _agr_clear_ghost
}}
add-zle-hook-widget line-init _agr_line_init_hook 2>/dev/null || true
"#
    )
}

/// Generate bash initialization code with embedded completions and ghost text
///
/// The generated code includes:
/// - `_AGR_LOADED=1` marker to detect if integration is loaded
/// - Embedded command list from clap
/// - Two-layer completion: commands first, then files for file-accepting commands
/// - Ghost text autosuggestion for file-accepting commands (limited in bash)
pub fn generate_bash_init() -> String {
    let commands = extract_commands();

    // Build simple space-separated command list
    let cmd_names: Vec<&str> = commands.iter().map(|c| c.name.as_str()).collect();
    let cmd_list = cmd_names.join(" ");

    // File-accepting commands
    let file_cmds: Vec<&str> = commands
        .iter()
        .filter(|c| c.accepts_file)
        .map(|c| c.name.as_str())
        .collect();
    let file_cmd_pattern = file_cmds.join(" ");

    format!(
        r#"# AGR Shell Integration - Bash
# Generated by: agr completions --shell-init bash
export _AGR_LOADED=1
_agr_ghost_style=$'\e[37;100m'
_agr_reset=$'\e[0m'
_agr_commands="{cmd_list}"
_agr_file_cmds="{file_cmd_pattern}"

_agr_complete() {{
    local cur="${{COMP_WORDS[COMP_CWORD]}}"
    local cmd="${{COMP_WORDS[1]}}"

    if [[ $COMP_CWORD -eq 1 ]]; then
        # First argument: complete command names
        COMPREPLY=($(compgen -W "$_agr_commands" -- "$cur"))
    elif [[ " $_agr_file_cmds " =~ " $cmd " ]]; then
        # File-accepting command: complete with cast files
        local files
        files=$(agr completions --files --limit 20 "$cur" 2>/dev/null)
        COMPREPLY=($(compgen -W "$files" -- "$cur"))
    elif [[ "$cmd" == "marker" ]] && [[ $COMP_CWORD -eq 3 ]]; then
        # marker add/list <file>: complete with cast files
        local files
        files=$(agr completions --files --limit 20 "$cur" 2>/dev/null)
        COMPREPLY=($(compgen -W "$files" -- "$cur"))
    fi
}}

complete -F _agr_complete agr

# =============================================================================
# Ghost text autosuggestion (limited in bash compared to zsh)
# =============================================================================
_agr_ghost_text=""
_agr_ghost_displayed=0

# Show ghost text suggestion when at file-accepting position
_agr_show_ghost() {{
    local line="$READLINE_LINE"
    _agr_ghost_text=""
    _agr_ghost_displayed=0

    # Check if we're at a file-accepting position
    if [[ "$line" =~ ^agr\ ({file_cmd_pattern})\ $ ]]; then
        _agr_ghost_text=$(agr completions --files --limit 1 2>/dev/null)
        if [[ -n "$_agr_ghost_text" ]]; then
            # Save cursor position, print ghost text with gray+dim background, restore cursor
            printf '\e[s%s%s%s\e[u' "$_agr_ghost_style" "$_agr_ghost_text" "$_agr_reset"
            _agr_ghost_displayed=1
        fi
    elif [[ "$line" =~ ^agr\ marker\ (add|list)\ $ ]]; then
        _agr_ghost_text=$(agr completions --files --limit 1 2>/dev/null)
        if [[ -n "$_agr_ghost_text" ]]; then
            printf '\e[s%s%s%s\e[u' "$_agr_ghost_style" "$_agr_ghost_text" "$_agr_reset"
            _agr_ghost_displayed=1
        fi
    fi
}}

# Accept the ghost text suggestion
_agr_accept_ghost() {{
    if [[ -n "$_agr_ghost_text" ]]; then
        READLINE_LINE="${{READLINE_LINE}}${{_agr_ghost_text}}"
        READLINE_POINT=${{#READLINE_LINE}}
        _agr_ghost_text=""
        # Clear the ghost display by erasing to end of line
        printf '\e[K'
        _agr_ghost_displayed=0
    fi
}}

# Clear ghost text display
_agr_clear_ghost() {{
    if [[ $_agr_ghost_displayed -eq 1 ]]; then
        printf '\e[K'
        _agr_ghost_displayed=0
    fi
    _agr_ghost_text=""
}}

# Wrapper for space key: insert space and show ghost
_agr_space_ghost() {{
    _agr_clear_ghost
    READLINE_LINE="${{READLINE_LINE:0:READLINE_POINT}} ${{READLINE_LINE:READLINE_POINT}}"
    ((READLINE_POINT++))
    _agr_show_ghost
}}

# Wrapper for Tab: accept ghost or trigger completion
_agr_tab_ghost() {{
    if [[ -n "$_agr_ghost_text" ]]; then
        _agr_accept_ghost
    fi
    # Note: We can't easily fall through to readline completion from bind -x
    # The user can press Tab again for normal completion
}}

# Bind space to show ghost (bash 4.0+)
if [[ ${{BASH_VERSINFO[0]}} -ge 4 ]]; then
    bind -x '"\x20":"_agr_space_ghost"'
    bind -x '"\C-g":"_agr_accept_ghost"'  # Ctrl+G accepts ghost
fi
"#
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn extract_commands_returns_visible_commands() {
        let commands = extract_commands();
        let names: Vec<&str> = commands.iter().map(|c| c.name.as_str()).collect();

        // Should include common commands
        assert!(names.contains(&"record"), "Should contain 'record'");
        assert!(names.contains(&"play"), "Should contain 'play'");
        assert!(names.contains(&"list"), "Should contain 'list'");
        assert!(names.contains(&"status"), "Should contain 'status'");

        // Should NOT include hidden commands
        assert!(
            !names.contains(&"completions"),
            "Should not contain hidden 'completions'"
        );
    }

    #[test]
    fn extract_commands_marks_file_accepting() {
        let commands = extract_commands();

        let play = commands.iter().find(|c| c.name == "play");
        assert!(play.is_some());
        assert!(play.unwrap().accepts_file);

        let analyze = commands.iter().find(|c| c.name == "analyze");
        assert!(analyze.is_some());
        assert!(analyze.unwrap().accepts_file);

        let status = commands.iter().find(|c| c.name == "status");
        assert!(status.is_some());
        assert!(!status.unwrap().accepts_file);
    }

    #[test]
    fn generate_zsh_init_contains_marker() {
        let init = generate_zsh_init();
        assert!(init.contains("_AGR_LOADED=1"));
    }

    #[test]
    fn generate_zsh_init_contains_commands() {
        let init = generate_zsh_init();
        assert!(init.contains("record"));
        assert!(init.contains("play"));
        assert!(init.contains("status"));
    }

    #[test]
    fn generate_zsh_init_contains_completion_function() {
        let init = generate_zsh_init();
        assert!(init.contains("_agr_complete()"));
        assert!(init.contains("compdef _agr_complete agr"));
    }

    #[test]
    fn generate_bash_init_contains_marker() {
        let init = generate_bash_init();
        assert!(init.contains("_AGR_LOADED=1"));
    }

    #[test]
    fn generate_bash_init_contains_commands() {
        let init = generate_bash_init();
        assert!(init.contains("record"));
        assert!(init.contains("play"));
        assert!(init.contains("status"));
    }

    #[test]
    fn generate_bash_init_contains_completion_function() {
        let init = generate_bash_init();
        assert!(init.contains("_agr_complete()"));
        assert!(init.contains("complete -F _agr_complete agr"));
    }

    #[test]
    fn zsh_init_is_valid_shell_syntax() {
        let init = generate_zsh_init();
        // Basic syntax checks - verify shell variables are properly formed
        assert!(init.contains("${"), "Should have shell variable syntax");
        assert!(
            !init.contains("{cmd_"),
            "Should not have unescaped format placeholders"
        );
        assert!(
            !init.contains("{{"),
            "Should not have double braces (format! escape artifacts)"
        );
    }

    #[test]
    fn bash_init_is_valid_shell_syntax() {
        let init = generate_bash_init();
        // Basic syntax checks - verify shell variables are properly formed
        assert!(init.contains("${"), "Should have shell variable syntax");
        assert!(
            !init.contains("{cmd_"),
            "Should not have unescaped format placeholders"
        );
        assert!(
            !init.contains("{{"),
            "Should not have double braces (format! escape artifacts)"
        );
    }

    #[test]
    fn zsh_init_contains_ghost_text_functions() {
        let init = generate_zsh_init();
        assert!(
            init.contains("_agr_show_ghost"),
            "Should contain ghost text show function"
        );
        assert!(
            init.contains("_agr_accept_ghost"),
            "Should contain ghost text accept function"
        );
        assert!(
            init.contains("_agr_clear_ghost"),
            "Should contain ghost text clear function"
        );
        assert!(
            init.contains("POSTDISPLAY"),
            "Should use zsh POSTDISPLAY for ghost text"
        );
        assert!(
            init.contains("zle -N"),
            "Should register zle widgets"
        );
    }

    #[test]
    fn bash_init_contains_ghost_text_functions() {
        let init = generate_bash_init();
        assert!(
            init.contains("_agr_show_ghost"),
            "Should contain ghost text show function"
        );
        assert!(
            init.contains("_agr_accept_ghost"),
            "Should contain ghost text accept function"
        );
        assert!(
            init.contains("_agr_clear_ghost"),
            "Should contain ghost text clear function"
        );
        assert!(
            init.contains("READLINE_LINE"),
            "Should use bash READLINE_LINE"
        );
        assert!(
            init.contains("bind -x"),
            "Should bind keys with bind -x"
        );
    }

    #[test]
    fn zsh_init_binds_space_for_ghost() {
        let init = generate_zsh_init();
        assert!(
            init.contains("bindkey ' '"),
            "Should bind space key for ghost text"
        );
    }

    #[test]
    fn zsh_init_binds_tab_for_accept() {
        let init = generate_zsh_init();
        assert!(
            init.contains("bindkey '^I'"),
            "Should bind Tab for accepting ghost"
        );
    }
}
